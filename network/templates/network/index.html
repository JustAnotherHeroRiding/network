{% extends "network/layout.html" %}
{% load static %}

{% block body %}
<div id="posts"
  class="text-white flex flex-col lg:w-1/3 md:w-2/4 min-w-[500px]  mx-auto min-h-screen border border-gray-500 rounded-xl my-6">
  <div id="allposts"></div>
  <div id="profile" data-email="{{ user.email }}" data-username=" {{ user.username}}" data-user-id=" {{ user.id }}">
  </div>

</div>

<script type="text/babel">



  if (window.location.href !== 'http://127.0.0.1:8000/') {
    window.location.href = 'http://127.0.0.1:8000/';
  }
  const MIN_TEXTAREA_HEIGHT = 32;


  // Kept geting errors when i didn't use a rootElement and it told me
  // That it downgraded me to the previous version of react
  // This is our root div where all the action is happening
  const rootElementAllPosts = document.getElementById("allposts");
  const rootAll = ReactDOM.createRoot(rootElementAllPosts);

  const rootElementProfile = document.getElementById("profile");
  const rootProfile = ReactDOM.createRoot(rootElementProfile);


  // These variables need to be changed depending on which profile we click so
  // that we can pass the data to the profile component
  // Might be easier to just build a django view that will fetch all data with just the id
  let email = rootElementProfile.getAttribute("data-email");
  let username = rootElementProfile.getAttribute("data-username");
  let user_id = rootElementProfile.getAttribute("data-user-id");

  // These are just for the logged in user and do not change, they are the initial values of the data tags which
  // come from the logged in user
  const current_email = rootElementProfile.getAttribute("data-email");
  const current_username = rootElementProfile.getAttribute("data-username");
  const current_user_id = rootElementProfile.getAttribute("data-user-id");








  // The profile component for showing the profile
  function Profile(props) {

    // The posts to render
    const [posts, setPosts] = React.useState([]);

    // Use states for followers and following so that they get dynamically updated
    const [followerCount, setFollowerCount] = React.useState(0);
    const [followingCount, setFollowingCount] = React.useState(0);


    // Checking if we are already following the user
    const [isFollowing, setIsFollowing] = React.useState(false);


    // The 3 parameters that we pass
    const username = props.username;
    const userId = props.user_id;
    const email = props.email
    const IsLoggedIn = props.isLoggedIn


    // Still not quite sure what useEffect is
    // Here we define the fetchPosts function but for the usedId, which will fetch his posts
    React.useEffect(() => {
      async function fetchPosts() {
        const response = await fetch(`/post/${userId.toString().trim()}`);
        const data = await response.json();
        setPosts(data);
      }
      // Here we fetch the follower and following counts for the userId, then we set them using the state that we defined above
      // This seems to be one of the coolest thing about react, used for the posts too
      // Trimming because it was for some reason including spaces and the api call did not work, same above
      async function fetchFollowCounts() {
        const response = await fetch(`user/followers/${userId.toString().trim()}`);
        const data = await response.json();
        setFollowerCount(data.follower_count);
        setFollowingCount(data.following_count);
      }
      // Calling both functions with the userId
      fetchPosts();
      fetchFollowCounts();
    }, [userId]);




    // Checking if the current user is following the profile that is being viewed
    React.useEffect(() => {
      if (IsLoggedIn) {
        async function fetchFollowing() {
          if (parseInt(current_user_id) !== parseInt(userId)) {
            const response = await fetch(`/user/is_following/${userId}`);
            const data = await response.json();
            setIsFollowing(data.is_following);
          }
        }

        fetchFollowing();
      }
    }, [current_user_id, userId]);


    // Calling the view that handles following the user
    // Sets IsFollowing to true and increases the followerCount
    const handleFollow = async () => {
      const response = await fetch(`/user/follow/${userId}`);
      const data = await response.json();
      if (response.ok) {
        setIsFollowing(true);
        setFollowerCount(followerCount + 1);
      } else {
        console.log(data.message);
      }
    };


    // Same as above only for unfollowing
    const handleUnfollow = async () => {
      const response = await fetch(`/user/unfollow/${userId}`);
      const data = await response.json();
      if (response.ok) {
        setIsFollowing(false);
        setFollowerCount(followerCount - 1);
      } else {
        console.log(data.message);
      }
    };


    // Implementing pages with just React and no django
    const [currentPage, setCurrentPage] = React.useState(1);
    // Setting the maximum posts per page to 10
    // This is probably how all those shop websites work 
    //where you choose how many items to show
    const [postsPerPage, setPostsPerPage] = React.useState(10);

    // Some funky logic to get the indexes for the posts on the page
    const indexOfLastPost = currentPage * postsPerPage;
    const indexOfFirstPost = indexOfLastPost - postsPerPage;

    // Slicing the posts that we fetched to only show the ones from the page
    // that we are currently on
    const [currentPosts, setCurrentPosts] = React.useState([]);

    React.useEffect(() => {
      if (posts.length > 0) {
        const indexOfLastPost = currentPage * postsPerPage;
        const indexOfFirstPost = indexOfLastPost - postsPerPage;
        setCurrentPosts(posts.slice(indexOfFirstPost, indexOfLastPost));
      }
    }, [currentPage, posts, postsPerPage]);


    // Calculate the total number of pages
    const pageNumber = [];
    for (let i = 1; i <= Math.ceil(posts.length / postsPerPage); i++) {
      pageNumber.push(i);
    }

    // Function to go to previous page
    const goToPrevPage = () => {
      setCurrentPage(prevPage => prevPage - 1);
    }

    // Function to go to next page
    const goToNextPage = () => {
      setCurrentPage(prevPage => prevPage + 1);
    }

    // Consts for editing post, using the same style as the new post textarea
    // Here I am tracking whether the edit post button has been clicked, the text that is being written and the post id 
    // at the end a ref for the textarea
    const [isEditing, setIsEditing] = React.useState(false);
    const [editedPostText, setEditedPostText] = React.useState("");
    const [editedPostId, setEditedPostId] = React.useState(null);
    const editTextRef = React.useRef(null);


    // Following any changes in the textarea
    const onEditTextChange = (event) => setEditedPostText(event.target.value);

    // Adjusting the text area size as more text is written, up to a limit
    React.useLayoutEffect(() => {
      if (editTextRef.current) {
        // Reset height - important to shrink on delete
        editTextRef.current.style.height = "inherit";
        // Set height
        editTextRef.current.style.height = `${Math.max(
          editTextRef.current.scrollHeight,
          MIN_TEXTAREA_HEIGHT
        )}px`;
      }
    }, [editedPostText, editTextRef]);


    // Function triggered by the edit post button, enters into edit view, sets the id of the post being edited
    // Prefills the text with body of the post
    const handleEditClick = (post) => {
      setIsEditing(true);
      setEditedPostId(post.id);
      setEditedPostText(post.body);

    };

    // Saving the changes by making a POST request to my edit view,updates the pody of the post
    // This is why we defined the post id of the post being edited earlier
    const handleSaveClick = () => {
      fetch(`/post/edit/${editedPostId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          body: editedPostText
        }),
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Failed to update post.');
          }
          // Updating the posts being shown so that the edit shows up instantly
          const updatedPosts = currentPosts.map((post) => {
            if (post.id === editedPostId) {
              return { ...post, body: editedPostText };
            }
            return post;
          });
          // Updating currents posts as that is what is being shown
          // Turning off edit view and resetting the edit textarea body to empty
          setCurrentPosts(updatedPosts);
          setIsEditing(false);
          setEditedPostText('');
        })
        .catch((error) => {
          console.error(error);
        });
    };


    // Cancels the edit view
    const handleCancelClick = () => {
      setIsEditing(false);
    };

    // Finding the liked posts of the user
    const [likedPosts, setLikedPosts] = React.useState([]);

    // I use this so that I know which posts the user has already liked and I can show the unlike button instead
    React.useEffect(() => {
      // Fetch the user's liked posts from the backend
      // Checking ofcourse if user is logged in
      if (IsLoggedIn) {
        fetch('/user/likes')
          .then(response => {
            if (response.ok) {
              return response.json();
            } else {
              throw new Error('Something went wrong');
            }
          })
          .then(data => {
            // Update the likedPosts state with the fetched data
            setLikedPosts(data.liked_posts);
          })
          .catch(error => {
            console.log(error);
          });
      }
    }, []); // Empty dependency array to only run the effect once when the component mounts




    // Function for liking posts, once again we pass the postId and we add it to likedPosts
    const LikePost = (postId) => {
      fetch(`/post/like/${postId}`)
        .then(response => {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error('Something went wrong');
          }
        })
        .then(data => {
          const updatedPosts = currentPosts.map(post => {
            if (post.id === postId) {
              return { ...post, likes: data.likes };
            } else {
              return post;
            }
          });
          setCurrentPosts(updatedPosts); // Update state using the setter function
          setLikedPosts([...likedPosts, postId]); // Add the liked post ID to the likedPosts state

        })
        .catch(error => {
          console.log(error);
          // Show the error message if user is not logged in or any other errors
          setLikeErrorPostId(postId)
          setLikeErrorMessage('Something went wrong. Make sure you are logged in.');
        });
    };

    // Reverse of the previous function, using the view for unliking posts to remove the postId from likedPosts
    const UnlikePost = (postId) => {
      fetch(`/post/unlike/${postId}`)
        .then(response => {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error('Something went wrong');
          }
        })
        .then(data => {
          const updatedPosts = currentPosts.map(post => {
            if (post.id === postId) {
              return { ...post, likes: data.likes };
            } else {
              return post;
            }
          });
          setCurrentPosts(updatedPosts); // Update state using the setter function
          setLikedPosts(likedPosts.filter(id => id !== postId)); // Remove the postId from the likedPosts state
        })
        .catch(error => {
          console.log(error);
        });
    }



    // 2 states for the like error message, the message and the post where the error has occurred 
    const [LikeErrorMessage, setLikeErrorMessage] = React.useState(null);
    const [LikeErrorPostId, setLikeErrorPostId] = React.useState(null);

    const timerRef = React.useRef(null);


    // Use effect for the fadeout of the non user like error
    React.useEffect(() => {
      // First we check for the message
      if (LikeErrorMessage) {
        // Clear the previous timer if it exists
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }

        // Set a timer to hide the error message after 3000ms (3 seconds)
        timerRef.current = setTimeout(() => {
          setLikeErrorMessage('');
        }, 3000);

        // Clear the timer if the component unmounts or the error message changes
        return () => clearTimeout(timerRef.current);
      }
    }, [LikeErrorMessage, LikeErrorPostId]);



    return (
      <div>

        <div className='p-4 border-b border-gray-500'>
          <div className='flex justify-between'>
            <h1 className=''>{email}</h1>
            <h3 className='text-3xl flex-row flex'><p className="text-gray-500">@</p>{username}</h3>
          </div>
          {/*<h4>{userId}</h4> */}
          {parseInt(current_user_id) !== parseInt(userId) && (
            <button className="px-4 py-2 border border-gray-600 rounded-3xl bg-orange-600 hover:bg-spectrum-h2 cursor-pointer"
              onClick={isFollowing ? handleUnfollow : handleFollow}>
              {isFollowing ? "Unfollow" : "Follow"}


            </button>
          )}
          <div className='flex justify-between'>
            <p>Followers: {followerCount}</p>
            <p>Following: {followingCount}</p>
          </div>

          <h2 className="flex justify-center text-4xl">Posts</h2>
        </div>
        {currentPosts.map(post => (
          <div className='border-b border-gray-500  px-4 py-4' key={post.id}>
            <p>{post.timestamp}</p>
            <div className="px-4 py-2 border border-gray-500 rounded-3xl my-4">
              {editedPostId === post.id && isEditing ? (
                <textarea className='w-full text-white bg-black resize-none'
                  value={editedPostText}
                  onChange={onEditTextChange}
                  ref={editTextRef}
                  style={{
                    minHeight: 64,
                    maxHeight: 400
                  }}
                />
              ) : (
                <p className='whitespace-pre-line'>{post.body}</p>
              )}
            </div>
            <div id={`like-error-${post.id}`} className={`text-red-600 ${LikeErrorMessage && LikeErrorPostId == post.id ? 'opacity-0' : 'opacity-100'
              } transition-opacity duration-[3000ms] ease-in-out`}>
              {LikeErrorMessage && LikeErrorPostId == post.id && (
                <p>{LikeErrorMessage}</p>
              )}
            </div>
            <div className="flex justify-between">


              <p>Likes: {post.likes}</p>
              <div>
                {current_user_id == userId && (
                  isEditing ? (
                    <>
                      <button className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2' onClick={handleSaveClick}>Save</button>
                      <button className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2' onClick={handleCancelClick}>Cancel</button>
                    </>
                  ) : (
                    <button className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2' onClick={() => handleEditClick(post)}>Edit Post</button>
                  )
                )}
                <button
                  onClick={() => {
                    if (likedPosts.includes(post.id)) {
                      UnlikePost(post.id);
                    } else {
                      LikePost(post.id);
                    }
                  }}
                  data-post-id={post.id}
                  className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white'
                >
                  {likedPosts.includes(post.id) ? 'Unlike' : 'Like'}
                </button>
              </div>
            </div>
          </div>
        ))}
        <div className="flex justify-between mt-6">
          {/* Previous page button */}
          <button
            disabled={currentPage === 1} // Disable if on first page
            onClick={goToPrevPage}
            className="text-2xl px-2 mx-2 bg-spectrum-h2 rounded-xl hover:bg-spectrum-h1"
          >
            &lt; Prev
          </button>
          <h1 className='text-4xl text-bold'>{currentPage}</h1>
          <button
          disabled={currentPage === Math.ceil(posts.length / postsPerPage)} // Disable if on last page
          onClick={goToNextPage}
          className="text-2xl px-2 mx-2 bg-spectrum-h2 rounded-xl hover:bg-spectrum-h1"
        >
          Next &gt;
        </button>
      </div>
        <div className="my-6">
          {pageNumber.map(number => (
            <a key={number} href='#' className='text-2xl px-2 mx-2 bg-spectrum-h2 rounded-xl' onClick={() => setCurrentPage(number)}>{number}</a>
          ))}
        </div>
      </div>
    );
  }

  function Posts() {
    
    // Consts for the new post textarea
    const textareaRef = React.useRef(null);
    const [value, setValue] = React.useState("");
    const onChange = (event) => setValue(event.target.value);

    // Logic for the resizing textarea
    React.useLayoutEffect(() => {
      // Reset height - important to shrink on delete
      textareaRef.current.style.height = "inherit";
      // Set height
      textareaRef.current.style.height = `${Math.max(
        textareaRef.current.scrollHeight,
        MIN_TEXTAREA_HEIGHT
      )}px`;
    }, [value]);

    // This gets triggered when the new post form submits
    function send_post(event) {
      event.preventDefault();
      const form = event.target;
      const body = form.postbody.value;
      
      // new post view to save the new post
      const data = { body };
      fetch('/post/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      })
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          console.log('Post saved successfully:', data);
          setValue(""); // Clear the textarea
          setPopUpValue(""); // As the popup new post uses this also, I want to clear it's value too
          // Refresh the posts with the newly added post so that the UI updates
          fetch('/post/all')
            .then(response => response.json())
            .then(posts => setPosts(posts))
            .catch(error => console.error('Error fetching posts:', error));

        })
        .catch(error => {
          console.error('There was a problem saving the post:', error);
          // Error message if the user is not logged in or the POST request fails for any reason
          alert("Post was not sent.\nMake sure that you are logged in.");
        });
    }



    // Consts for the posts on the screen
    const [posts, setPosts] = React.useState([]);

    // This decides whether to show the posts or the profile
    const [showAllPosts, setShowAllPosts] = React.useState(true);

    // To show following or all posts, depending on which is being viewed
    const [postsHeader, setPostsHeader] = React.useState('');



    // Main function for fetching the posts
    function fetchPosts() {
      event.preventDefault()
      setShowAllPosts(true);
      // Here we set it to All Posts by default, only when the following sidebar button is clicked we switch it to following
      setPostsHeader('All Posts')

      fetch('/post/all')
        .then(response => response.json())
        .then(posts => setPosts(posts))
        .catch(error => console.error('Error fetching posts:', error));
    }

    // Will fetch posts once on component mount
    React.useEffect(() => {
      fetchPosts();
    }, []);


    // Here we fetch the posts of users that the current user is following
    function fetchPostsFollowing() {
      setShowAllPosts(true);
      // Reseting page to page 1 and setting header to following, if this was clicked from the profile view
      // ShowAllPosts is set to true to show the posts
      setCurrentPage(1);
      setPostsHeader('Following')


      fetch('/post/user/following')
        .then(response => response.json())
        .then(posts => {
          setPosts(posts);
          // Update UI with fetched posts
        })
        .catch(error => console.error('Error fetching posts:', error));
    }



    // Here we get the email, username and user_id of the current user which are stored in the data attributes
    const [email, setEmail] = React.useState(rootElementProfile.getAttribute('data-email'));
    const [username, setUsername] = React.useState(rootElementProfile.getAttribute('data-username'));
    const [user_id, setUser_id] = React.useState(rootElementProfile.getAttribute('data-user-id'));


    // Loading the profile part of the html if the profile button gets clicked from the sidebar
    const handleProfileClickSidebar = (username, email, user_id) => {
      event.preventDefault();
      setShowAllPosts(false);
      setUsername(username);
      setEmail(email);
      setUser_id(user_id);
    }

    // If the profile gets clicked from the posts
    const handleProfileClick = (username, email, user_id) => {
      event.preventDefault();
      setShowAllPosts(false);
      setUsername(username);
      setEmail(email);
      setUser_id(user_id);
    }



    // Going back to the posts from the profile view
    const handleBackClick = (event) => {
      event.preventDefault();
      setShowAllPosts(true);
    };
    // Defining the all posts sidebar button
    const allPosts = document.querySelector('#sidebar-all-posts');
    // Checking that there is no event listener already as at first i had this issue where there were tens of event listeners being set
    // Every time something changed
    if (!allPosts.hasAttribute('data-event-listener-added')) {
      allPosts.addEventListener('click', fetchPosts);
      allPosts.setAttribute('data-event-listener-added', true);
    }

    // What the user can do depends a lot on whether he is logged in, setting to false by default
    const [isLoggedIn, setIsLoggedIn] = React.useState(false);
    // Checks if the user is currently writing a new post using the popup 
    const [newPost, setNewPost] = React.useState(false)


    // new post always prints false
    // let's see why that is later

    // The opacity is also applied to the popup
    // Need to see how i can only dim the background

    // General function to handle the sidebar new post button
    // If its already open it will close the window and clear the text, if it is closed it will open the popup window
    const NewPost = (event) => {
      event.preventDefault();
      setNewPost((prevNewPost) => {
        if (!prevNewPost) {
          setPopUpValue("")
          return true;
        } else {
          return false;
        }
      });
    };


    // Defining the sidebar new post button
    const newPostButton = document.querySelector('#sidebar-new-post');


    // Function to check if the user is logged in and if the api route returns true then we add all the needed event listeners
    // These buttons are not rendered if the user is not logged in so we have to check first so that we dont error out
    function checkLoggedIn() {
      fetch("http://127.0.0.1:8000/check/login", {
        credentials: "same-origin"
      })
        .then(response => response.json())
        .then(data => {
          if (data.is_authenticated) {
            const profileButton = document.querySelector('#sidebar-profile');
            const followingButton = document.querySelector('#sidebar-following');



            // Check if the event listeners have already been added
            if (!profileButton.hasAttribute('data-event-listener-added')) {
              profileButton.addEventListener('click', () => handleProfileClickSidebar(current_username, current_email, current_user_id));
              profileButton.setAttribute('data-event-listener-added', true);
            }

            if (!newPostButton.hasAttribute('data-event-listener-added')) {
              newPostButton.addEventListener('click', NewPost);
              newPostButton.setAttribute('data-event-listener-added', true);
            }

            if (!followingButton.hasAttribute('data-event-listener-added')) {
              followingButton.addEventListener('click', fetchPostsFollowing);
              followingButton.setAttribute('data-event-listener-added', true);
            }

            // Set isLoggedIn to true which can be used to see if the user is logged in for other purposes
            setIsLoggedIn(true);
            // If the user is not logged in then we add an alert to the new post button to explain why the user cannot make a new post
          } else {
            if (!newPostButton.hasAttribute('data-event-listener-added')) {
              newPostButton.addEventListener('click', () => {
                alert('Only logged in users can make new posts.');
              });
              newPostButton.setAttribute('data-event-listener-added', true);
            }
          }
        })
        .catch(error => console.error(error));
    }


    // Consts for handling the pages, 2 states to keep track of the page the user is on and the posts that should be shown on that page
    // Hardcoding number of posts to 10 per page
    const [currentPage, setCurrentPage] = React.useState(1);
    const postsPerPage = 10;
    const [currentPosts, setCurrentPosts] = React.useState([]);

    // use effect which gets triggered when the 2 states above or the posts change
    React.useEffect(() => {
      // Checking that there are posts as before when i had to render 0 posts i had issues with the pages cannot remember currently what it was
      if (posts.length > 0) {
        const indexOfLastPost = currentPage * postsPerPage;
        const indexOfFirstPost = indexOfLastPost - postsPerPage;
        // Using simple logic to get the 10 posts that need to be rendered
        // If we are on page 3, the index of the last post is 30 and index of the first post is 20
        setCurrentPosts(posts.slice(indexOfFirstPost, indexOfLastPost));
      } else {
        setCurrentPosts(posts)
      }
    }, [currentPage, posts, postsPerPage]);




    // Calculate the total number of pages
    // This is for the pages at the bottom of the page
    const pageNumber = [];
    for (let i = 1; i <= Math.ceil(posts.length / postsPerPage); i++) {
      pageNumber.push(i);
    }
    
    // The reqs state that we need a next and previous button and these functions handle them, simple as we just reduce or increase the page
    // Function to go to previous page
    const goToPrevPage = () => {
      setCurrentPage(prevPage => prevPage - 1);
    }

    // Function to go to next page
    const goToNextPage = () => {
      setCurrentPage(prevPage => prevPage + 1);
    }

    const [likedPosts, setLikedPosts] = React.useState([]);




    // This is returning false now and not updating the liked posts of the user

    // Checking for the liked posts of the user, doubled with the function from the profile component, newbie react mistake
    React.useEffect(() => {
      checkLoggedIn();
      // Fetch the user's liked posts from the backend
      if (isLoggedIn) {
        fetch('/user/likes')
          .then(response => {
            if (response.ok) {
              return response.json();
            } else {
              throw new Error('Something went wrong');
            }
          })
          .then(data => {
            // Update the likedPosts state with the fetched data
            setLikedPosts(data.liked_posts);
          })
          .catch(error => {
            console.log(error);
          });
      }
    }, [isLoggedIn]); // Added isLoggedIn usestate as a dependency as we need to check for it 



    // Again doubled with profile component
    const [LikeErrorMessage, setLikeErrorMessage] = React.useState(null);
    const [LikeErrorPostId, setLikeErrorPostId] = React.useState(null);

    const timerRef = React.useRef(null);



    React.useEffect(() => {
      //const errorElement = document.getElementById(`like-error-${LikeErrorPostId}`);


      if (LikeErrorMessage) {
        // Clear the previous timer if it exists
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }

        // Set a timer to hide the error message after 3000ms (3 seconds)
        timerRef.current = setTimeout(() => {
          setLikeErrorMessage('');
        }, 3000);

        // Clear the timer if the component unmounts or the error message changes
        return () => clearTimeout(timerRef.current);
      }
    }, [LikeErrorMessage, LikeErrorPostId]);


    const LikePost = (postId) => {

      fetch(`/post/like/${postId}`)
        .then(response => {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error('Something went wrong');

          }
        })
        .then(data => {
          const updatedPosts = currentPosts.map(post => {
            if (post.id === postId) {
              return { ...post, likes: data.likes };
            } else {
              return post;
            }
          });
          setCurrentPosts(updatedPosts); // Update state using the setter function
          setLikedPosts([...likedPosts, postId]); // Add the liked post ID to the likedPosts state
        })
        .catch(error => {
          setLikeErrorPostId(postId)
          setLikeErrorMessage('Something went wrong. Make sure you are logged in.');
          console.log(error);
        });
    }

    const UnlikePost = (postId) => {
      fetch(`/post/unlike/${postId}`)
        .then(response => {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error('Something went wrong');
          }
        })
        .then(data => {
          const updatedPosts = currentPosts.map(post => {
            if (post.id === postId) {
              return { ...post, likes: data.likes };
            } else {
              return post;
            }
          });
          setCurrentPosts(updatedPosts); // Update state using the setter function
          setLikedPosts(likedPosts.filter(id => id !== postId)); // Remove the postId from the likedPosts state
        })
        .catch(error => {
          console.log(error);
        });
    }

    // Edit post consts
    const [isEditing, setIsEditing] = React.useState(false);
    const [editedPostText, setEditedPostText] = React.useState("");
    const [editedPostId, setEditedPostId] = React.useState(null);
    const editTextRef = React.useRef(null);



    const onEditTextChange = (event) => setEditedPostText(event.target.value);


    React.useLayoutEffect(() => {
      if (editTextRef.current) {
        // Reset height - important to shrink on delete
        editTextRef.current.style.height = "inherit";
        // Set height
        editTextRef.current.style.height = `${Math.max(
          editTextRef.current.scrollHeight,
          MIN_TEXTAREA_HEIGHT
        )}px`;
      }
    }, [editedPostText, editTextRef]);





    const handleEditClick = (post) => {
      setIsEditing(true);
      setEditedPostId(post.id);
      setEditedPostText(post.body);

    };

    const handleSaveClick = () => {
      fetch(`/post/edit/${editedPostId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          body: editedPostText
        }),
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Failed to update post.');
          }
          const updatedPosts = currentPosts.map((post) => {
            if (post.id === editedPostId) {
              return { ...post, body: editedPostText };
            }
            return post;
          });
          setCurrentPosts(updatedPosts);
          setIsEditing(false);
          setEditedPostText('');
        })
        .catch((error) => {
          console.error(error);
        });
    };



    const handleCancelClick = () => {
      setIsEditing(false);
    };


    const [popUpValue, setPopUpValue] = React.useState("");
    const onPopUpChange = (event) => setPopUpValue(event.target.value);
    const popUpRef = React.useRef(null);

    const [textAreaHeight, setTextAreaHeight] = React.useState(MIN_TEXTAREA_HEIGHT);

    React.useLayoutEffect(() => {
      if (popUpRef.current) {
        // Reset height - important to shrink on delete
        popUpRef.current.style.height = "inherit";
        // Set height
        const newHeight = Math.max(popUpRef.current.scrollHeight, MIN_TEXTAREA_HEIGHT);
        popUpRef.current.style.height = `${newHeight}px`;
        // Update textarea height state
        setTextAreaHeight(newHeight);
      }
    }, [popUpValue, popUpRef]);

    let popupHeightStyle = { height: `${parseInt(textAreaHeight) + 100}px` };

    // Resizing the pop up new post window requires more work
    // Right now there is no max height and it keeps going
    // also there is an hr floating outside of the box, the window needs a min h


    React.useEffect(() => {
      const handleEsc = (event) => {
        if (event.key === "Escape") {
          setNewPost((prevNewPost) => {
            if (prevNewPost) {
              return false;
            }
          });
        }
      };
    
      document.addEventListener("keydown", handleEsc);
    
      return () => {
        document.removeEventListener("keydown", handleEsc);
      };
    }, [newPost]);
    



    return (
      <div className='z-10 relative'>
        {newPost && (
          <div id="newpostparent">
          <div className="popup bg-spectrum-h6 p-2 rounded-xl" style={popupHeightStyle}>
            <div className="flex justify-end">
            <a className="cursor-pointer text-2xl border border-gray-500 rounded-2xl bg-spectrum-h1 px-2"  
            onClick={NewPost} >X</a>
          </div>

            <form id='newpost' onSubmit={send_post} 
            className='flex-col flex my-6 border border-gray-500 pt-12 resize-none bg-black rounded-xl '>
              <textarea type="text"
                onChange={onPopUpChange}
                ref={popUpRef}
                style={{
                  minHeight: MIN_TEXTAREA_HEIGHT,
                  maxHeight: 400
                }}
                value={popUpValue}
                name="postbody"
                id="postbody"
                placeholder="What's on your mind?"
                rows='3'
                className='bg-black px-6 placeholder:text-gray-500 outline-none' />
              <hr className="border-gray-500" />
              <input type="submit" id="post-submit" className="cursor-pointer	hover:bg-spectrum-h2 bg-orange-600 text-white font-semibold py-2 mt-6 px-6 rounded-3xl shadow mb-10 w-24 ml-auto mr-6 resize-none" value="Send" />
            </form>
          </div>
        </div>
        )}

        <div>
          {showAllPosts ? (
            <div>
              <h1 className='text-3xl ml-2 mt-6'>Home</h1>
              <form id='newpost' onSubmit={send_post} className='flex-col flex my-6 border-y border-gray-500 pt-6 resize-none '>
                <textarea type="text"
                  onChange={onChange}
                  ref={textareaRef}
                  style={{
                    minHeight: MIN_TEXTAREA_HEIGHT,
                    maxHeight: 400
                  }}
                  value={value}
                  name="postbody"
                  id="postbody"
                  placeholder="What's on your mind?"
                  rows='3'
                  className='bg-black px-6 placeholder:text-gray-500 outline-none' />
                <hr className="border-gray-500" />
                <input type="submit" id="post-submit" className="cursor-pointer	hover:bg-spectrum-h2 bg-orange-600 text-white font-semibold py-2 mt-6 px-6 rounded-3xl shadow mb-10 w-24 ml-auto mr-6 resize-none" value="Send" />
              </form>
              <h1 className='text-4xl flex justify-center border-b border-gray-500 pb-6'>{postsHeader}</h1>
              {currentPosts.map(post => (
                <div key={post.id} className='border-b border-gray-500 px-4 py-4 hover:bg-gray-900 hover:border-white'>
                  <p>Posted by <a id='profile-link' className='text-blue-600 hover:underline' href='' onClick={() =>
                    handleProfileClick(post.user, post.user_mail, post.user_id)}> {post.user} </a>
                    on {post.timestamp}</p>
                  <div className="px-4 py-2 border border-gray-500 rounded-3xl my-4">
                    {editedPostId === post.id && isEditing ? (
                      <textarea className='w-full bg-black text-white resize-none'
                        value={editedPostText}
                        onChange={onEditTextChange}
                        ref={editTextRef}
                        style={{
                          minHeight: MIN_TEXTAREA_HEIGHT,
                          maxHeight: 400
                        }}
                      />
                    ) : (
                      <p className='whitespace-pre-line'>{post.body}</p>
                    )}
                  </div>
                  <div id={`like-error-${post.id}`} className={`text-red-600 ${LikeErrorMessage && LikeErrorPostId == post.id ? 'opacity-0' : 'opacity-100'
                    } transition-opacity duration-[3000ms] ease-in-out`}>
                    {LikeErrorMessage && LikeErrorPostId == post.id && (
                      <p>{LikeErrorMessage}</p>
                    )}
                  </div>
                  <div className='flex justify-between'>
                    <p>Likes: {post.likes}</p>

                    <div>
                      {post.user_id == current_user_id && (
                        <>
                          {isEditing ? (
                            <>
                              <button className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2' onClick={handleSaveClick}>Save</button>
                              <button className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2' onClick={handleCancelClick}>Cancel</button>
                            </>
                          ) : (
                            <button className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2' onClick={() => handleEditClick(post)}>Edit Post</button>

                          )}
                        </>
                      )}
                      <button
                        onClick={() => {
                          if (likedPosts.includes(post.id)) {
                            UnlikePost(post.id);
                          } else {
                            LikePost(post.id);
                          }
                        }}
                        data-post-id={post.id}
                        className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white'
                      >
                        {likedPosts.includes(post.id) ? 'Unlike' : 'Like'}
                      </button>

                    </div>
                  </div>
                </div>
              ))}
              <div className="flex justify-between mt-6">
                {/* Previous page button */}
                <button
                  disabled={currentPage === 1} // Disable if on first page
                  onClick={goToPrevPage}
                  className="text-2xl px-2 mx-2 bg-spectrum-h2 rounded-xl hover:bg-spectrum-h1"
                >
                  &lt; Prev
                </button>
                <h1 className='text-4xl text-bold'>{currentPage}</h1>
                <button
                disabled={currentPage === Math.ceil(posts.length / postsPerPage) || posts.length === 0} // Disable if on last page or if there are no posts
                onClick={goToNextPage}
                className="text-2xl px-2 mx-2 bg-spectrum-h2 rounded-xl hover:bg-spectrum-h1"
              >
                Next &gt;
              </button>
            </div>
              <div className="my-6">
                {pageNumber.map(number => (
                  <a key={number} href='#' className='text-2xl px-2 mx-2 bg-spectrum-h2 rounded-xl' onClick={() => setCurrentPage(number)}>{number}</a>
                ))}
              </div>
              
            </div>
          ) : (

            <div className='flex flex-col'>
              <div className='flex justify-end'>
                {newPost ? (
                  <>
                  <button href='' disabled className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2 relative mt-6  opacity-40' 
                  >Back to All Posts</button>                  </>
                ) : (
                  <button href='' className='hover:bg-orange-600 rounded-3xl px-4 py-2 border border-white mr-2 relative mt-6' 
                  onClick={handleBackClick}>Back to All Posts</button>

                )}
                </div>

              <Profile username={username} email={email} user_id={user_id} isLoggedIn={isLoggedIn} />

            </div>

          )}
        </div>
      </div>
    );

  }

  rootAll.render(<Posts />);

</script>
{% block script %}
<script src="{% static 'network/network.js' %}"></script>
{% endblock %}
{% endblock %}